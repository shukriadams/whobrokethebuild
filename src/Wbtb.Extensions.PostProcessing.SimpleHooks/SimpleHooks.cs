using System.Reflection;
using Wbtb.Core.Common;

namespace Wbtb.Extensions.PostProcessing.SimpleHooks
{
    public class SimpleHooks : Plugin, IPostProcessorPlugin
    {
        #region PROPERTIES

        private readonly Logger _logger;

        private readonly PluginProvider _pluginProvider;

        private readonly BuildLogTextParser _buildLogTextParser;

        #endregion

        #region CTORS

        public SimpleHooks(Logger log, PluginProvider pluginProvider, BuildLogTextParser buildLogTextParser)
        {
            _logger = log;
            _pluginProvider = pluginProvider;
            _buildLogTextParser = buildLogTextParser;

        }

        #endregion

        #region METHODS

        PluginInitResult IPlugin.InitializePlugin()
        {
            Response<SimpleHooksConfig> response = this.ContextPluginConfig.Deserialize<SimpleHooksConfig>("Custom");
            if (response.Error != null)
                throw new ConfigurationException($"Could not deserialize plugin config {this.ContextPluginConfig.Key} to type {TypeHelper.Name<SimpleHooksConfig>()} : {response.Error}");

            if (string.IsNullOrEmpty(response.Value.KeyHook))
                throw new ConfigurationException($"{this.ContextPluginConfig.Key} must define \"KeyHook\" value, which must be a registered plugin key.");

            // ideally we also want to verify that KeyHook points to a valid and registered LogParser plugin, but we don't have the raw
            // plugin config list here. We can however soft-verify this in the job config step below by confirming a logparser with
            // that key is registered to the job.

            return new PluginInitResult
            {
                SessionId = Guid.NewGuid().ToString(),
                Success = true
            };
        }

        void IPostProcessorPlugin.VerifyJobConfig(Job job)
        {
            Response<SimpleHooksConfig> response = this.ContextPluginConfig.Deserialize<SimpleHooksConfig>("Custom");

            if (!job.LogParsers.Contains(response.Value.KeyHook))
                throw new ConfigurationException($"{this.ContextPluginConfig.Key} on job \"{job.Name}\" defines a KeyHook \"{response.Value.KeyHook}\", but this KeyHook is not a LogParser on this job.");
        }

        PostProcessResult IPostProcessorPlugin.Process(Build build)
        {
            SimpleHooksConfig config = this.ContextPluginConfig.Deserialize<SimpleHooksConfig>("Custom").Value;

            IDataPlugin data = _pluginProvider.GetFirstForInterface<IDataPlugin>();
            IEnumerable<BuildLogParseResult> logParseResults = data.GetBuildLogParseResultsByBuildId(build.Id);

            foreach (BuildLogParseResult buildLogParseResult in logParseResults)
            {
                Response<ParsedBuildLogText> parsedTextResponse = _buildLogTextParser.Parse(buildLogParseResult.ParsedContent);
                if (!string.IsNullOrEmpty(parsedTextResponse.Error))
                {
                    _logger.Error(this, parsedTextResponse.Error);
                    continue;
                }

                if (parsedTextResponse.Value == null)
                    continue;

                // look for parse results generated by the named jenkins fail log parser. If that plugin generated
                // a parse result, we treat it as proof of a jenkins failure
                if (parsedTextResponse.Value.Key == config.KeyHook)
                {
                    // a build can have only one mutation report, don't generate if on already exists
                    if (data.GetMutationReportByBuild(build.Id) == null)
                    {
                        data.SaveMutationReport(new MutationReport
                        {
                            IncidentId = build.IncidentBuildId,
                            BuildId = build.Id,
                            MutationId = build.Id,
                            Processor = this.GetType().Name,
                            Summary = string.IsNullOrEmpty(config.Description) ? config.KeyHook : config.Description,
                            Status = "Break"
                        });
                    }
                    else
                        _logger.Warn(this, $"Aborted mutation report, another report exists");
                }
            }

            return new PostProcessResult
            {
                Passed = true,
                Result = "Nothing found"
            };
        }

        #endregion
    }
}
